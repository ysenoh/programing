<!-- --*-coding:utf-8-*-- -->
 
[\[Google Code Jam\]](../README.md)

# コンテスト
GoogleCodeJam 2017 Round1C

スコアを見ると、Round1Cを通過する(1000位以内に入る)のに必要なのは、A B 完答。  
Round1Cは、ギリギリながらなんとか通過。  
やはり3回目ともなると、上位陣がもういないので、だいぶラクになります。  

# <a name="Problem_A">Problem A. Ample Syrup
## 問題
https://code.google.com/codejam/contest/3274486/dashboard#s=p0

+ N枚あるパンケーキのうち、K枚をピラミッド状に積み重ねて、上面と側面の合計を最大となるようにする。
+ その時の面積を求めよ

## 方針
側面が大きい方から順に並べた時、先頭のK-1枚は必ず使用される。  
残りのパンケーキの中から、面積が最大になるものを選び、それを加える。  

+ [コード](a.py)

## 感想
もう少し詰められそうな気もするが、そこまでパフォーマンスを要求する必要もないので、比較的安全な実装で済ませた。


# <a name="Problem_B">Problem B. Parenting Partnering
## 問題
https://code.google.com/codejam/contest/3274486/dashboard#s=p1

+ 夫と妻で子供の面倒をみる時間を決める
+ 平等に 720分(12時間)ずつ分担する
+ それぞれ、自分の仕事で外せない時間帯が複数ある
+ 交代しなければならない最小回数を求めよ
+ 外せない時間帯は、日をまたぐことはない
+ 夜中の12時に交代する場合も、それは1回としてカウントする

## 方針
外せない時間帯は相方がやるしかないので、逆にすればかならず受け持つ時間と見ることができる。  
夫の後に妻(またはその逆)の場合は、1回は交代が必要で2回以上は不要である。  
夫の後に夫(または妻の後に妻)の場合は、それを1回にまとめられれば、交代の回数が減る。  
つまり、それぞれに対して、受け持ち時間の合計が720を超えないように、その隙間に入る時間が短いものから詰めれば良い。  

+ [コード](b.py)

## 感想
落ち着いて解けばどうということは無い問題。  


# <a name="Problem_C">Problem C. Core Training
## 問題
https://code.google.com/codejam/contest/3274486/dashboard#s=p2

+ N個のユニットが存在し、それらが正しく動作する可能性はP_iである
+ そのうちK個のユニットが正しく動作すれば、全体で正しく動できる
+ 各ユニットに対して、合計で U だけ確率を上げることができる
+ 全体が正しく動作する確率はいくつまであげられるか


## 方針
### Small dataset 1
small datase 1 では、N=Kであるので、一番ダメなユニットから良くしていけば良い。  

+ [コード](c1.py)

### Small dataset 2
多分、上位K個に対して、small datase 1と同じように対応して、最後にそのなかのK以上個が
正しく動作する確率を求めれば良いのだと思うが、テストケースを通過せず。  
ひとまず保留とするが、コードは公開。  

+ [コード(正しく動作していない)](c2.py)

### 感想
dataset 1 は、さほど難しくないのに、コンテストでは時間も少なくて、パニクっていたのか正当せず。  

dataset 2 はこれで良いと思ったのだが。  
見落としがあるのか、根本的に間違っているのか。  

(追記)  
3つ内2つでOKの場合でも、[0, 0.15, 0.15] より [0.1, 0.1, 0.1] の方が高いという反例を教えていただきました。(つまり根本的に間違ってる)  






